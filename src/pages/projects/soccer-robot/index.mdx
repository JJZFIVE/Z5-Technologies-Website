import { ArticleLayout } from '@/components/ArticleLayout'
import Image from 'next/image'
import soccerGif from './soccer.gif'
import frontAngle from './frontAngle.png'

export const meta = {
  author: 'Joe Zakielarz',
  date: 'Fall 2023',
  dateForOrdering: '2023-12-01',
  header: 'Soccer Robot Arm: ECE383 School Project',
  title: 'Soccer Robot Arm: ECE383 School Project',
  description: 'Robot arm that kicks soccer soals (better than I could)',
}

export default (props) => <ArticleLayout meta={meta} {...props} />

## Inspiration

This was a school project my senior fall in ECE383: Introduction to Robotics. Our system uses a UR5e robot to kick a soccer ball into a net guarded by obstacles.
The arm awaits a console input of L, M, or R, and kicks the ball into the left, middle, or right side of the net depending on the input character.
A message will print in the console saying whether there was a goal. Then, pressing Enter into the console spawns a new soccer ball in front of the arm and spawns a new obstacle in a random position in front of the goal.

<Image src={soccerGif} alt="Video of arm in action" draggable={false} />
<div align="center">_Above: The UR5e robot arm in action. Goooalllll!_</div>

## Learnings and Takeaways

We learned it is important to understand the format of a world and a model file in Gazebo early on. These files make up the entirety of the Gazebo world that the robot is working in and having the ability to quickly modify these files to add things like sensors and external components, such as a goal, is imperative.
Once we understood the makeup of a world file and how it incorporates submodules like model files, it became easy to make the environment respond to actions that happen in the world, like the ball hitting the back of the net to indicate a goal.
Another takeaway was how to spawn new models into Gazebo during runtime from the Python script. We learned that Python can execute subprocesses, which are useful because spawning new models into Gazebo happens from the command line.
This is important to know for future robot programming assignments, since ROS commands are also generally executed from the terminal, such as setting up or removing listeners and nodes.

<Image src={frontAngle} alt="The goal from the front" draggable={false} />
<div align="center">_Above: The goal from the front_</div>

## Challenges

One challenge that we faced was getting the Gazebo plugin for the contact sensor to start working. A lot of research went into figuring out which plugin would be the best to use and understanding the code base for how the plugin worked and what type of messages it relayed to ROS so that we could parse these messages for data.
Over time and with a lot of debugging in the Gazebo world, we were able to understand the ContactsStage message format and figure out when to sense that a goal had been scored. It was easiest to sense when the ball made contact with the back of the net, because there was a clear collision there in the Gazebo world.
The other challenge was getting the robot to consistently get into an initial position without errors. This was because in some configurations, the robot would plan to move through itself when attempting to get to a certain pose. This required reworking the path and final values in RViz to make it consistent and more accurate.
Now, the robot should be able to get from its initial pose to any pre-kickoff starting pose without control errors.

## Team

- <a
    target="_blank"
    rel="noreferrer"
    href="https://www.linkedin.com/in/nick-ph-ward/"
  >
    Nick Ward
  </a>
- <a target="_blank" rel="noreferrer" href="https://www.linkedin.com/in/qmac/">
    Quentin MacFarlane
  </a>
- <a
    target="_blank"
    rel="noreferrer"
    href="https://www.linkedin.com/in/shane-simkin-194a95207/"
  >
    Shane Simkin
  </a>

## Tools

We built this Soccer Arm with the following tools:

1. ROS (Robot Operating System)
2. RosPy / Python
3. Gazebo
4. MoveIt
